"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePointCollection = usePointCollection;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _reactBaiduMapMap = require("@uiw/react-baidu-map-map");
var _reactBaiduMapUtils = require("@uiw/react-baidu-map-utils");
var EVENTS = ['onClick', 'onMouseOver', 'onMouseOut'];
function usePointCollection() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var shape = props.shape,
    color = props.color,
    size = props.size;
  var _useMapContext = (0, _reactBaiduMapMap.useMapContext)(),
    map = _useMapContext.map;
  var _useState = (0, _react.useState)(props.points),
    _useState2 = (0, _slicedToArray2.default)(_useState, 2),
    points = _useState2[0],
    setPoints = _useState2[1];
  var _useState3 = (0, _react.useState)(),
    _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
    pointCollection = _useState4[0],
    setPointCollection = _useState4[1];
  var getPoints = function getPoints() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var result = [];
    data.forEach(function (item) {
      result.push(new BMap.Point(item[0], item[1]));
    });
    return result;
  };
  (0, _react.useEffect)(function () {
    if (!BMap || !map) return;
    // 判断当前浏览器是否支持绘制海量点
    if (document && !document.createElement('canvas').getContext) return;
    var opts = {
      shape: shape,
      color: color,
      size: size
    };
    if (!pointCollection) {
      if (!opts.size) opts.size = BMAP_POINT_SIZE_SMALL;
      if (!opts.shape) opts.shape = BMAP_POINT_SHAPE_WATERDROP;
      if (!opts.color) opts.color = '#d340c3';
      var _pointCollection = new BMap.PointCollection(getPoints(points), opts);
      // pointCollection.clear();
      map.addOverlay(_pointCollection);
      setPointCollection(_pointCollection);
      EVENTS.forEach(function (evnetName) {
        if (props[evnetName]) {
          var name = evnetName.replace(/^on/, '').toLowerCase();
          _pointCollection.addEventListener(name, props[evnetName]);
        }
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [map]);
  (0, _react.useEffect)(function () {
    if (pointCollection && points) {
      // pointCollection.clear();
      pointCollection.setPoints(getPoints(points));
    }
  }, [points, pointCollection]);
  (0, _reactBaiduMapUtils.useVisiable)(pointCollection, props);
  (0, _reactBaiduMapUtils.useEventProperties)(pointCollection, props, ['onClick', 'onMouseOver', 'onMouseOut']);
  (0, _reactBaiduMapUtils.useProperties)(pointCollection, props, ['Styles']);
  return {
    pointCollection: pointCollection,
    setPointCollection: setPointCollection,
    points: points,
    setPoints: setPoints
  };
}
//# sourceMappingURL=usePointCollection.js.map